using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OneOf.TypeExtensions.Generator;

[Generator]
public class OneOfTypeExtensionsGenerator : IIncrementalGenerator
{
    private static readonly char[] InvalidPathChars = System.IO.Path.GetInvalidPathChars().Concat(new []{ '?', '<', '>', '.' }).ToArray();
    private const string AutoGeneratedHeader = "// <auto-generated>";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<OneOfArgumentsInfo?> oneOfUsages = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsOneOfTypeSyntax(node),
                transform: static (ctx, cancellationToken) => GetOneOfTypeInfo(ctx, cancellationToken))
            .WithComparer(new OneOfArgumentsComparer())
            .Where(static typeInfo => typeInfo != null);

        var collected = oneOfUsages.Collect();

        context.RegisterSourceOutput(collected, static (spc, source) => Execute(source, spc));
    }

    private static bool IsOneOfTypeSyntax(SyntaxNode node)
    {
        return node is GenericNameSyntax { Identifier.ValueText: "OneOf" };
    }

    private static OneOfArgumentsInfo? GetOneOfTypeInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not GenericNameSyntax gns || gns.Identifier.ValueText != "OneOf") return null;

        var symbolInfo = context.SemanticModel.GetSymbolInfo(gns);

        cancellationToken.ThrowIfCancellationRequested();

        if (symbolInfo.Symbol is not INamedTypeSymbol namedTypeSymbol) return null;

        var typeArguments = namedTypeSymbol.TypeArguments.Select(HelperExtensions.GetTypeArgument).ToArray();

        cancellationToken.ThrowIfCancellationRequested();

        return new OneOfArgumentsInfo(typeArguments);
    }

    private static void Execute(IEnumerable<OneOfArgumentsInfo> typeInfos, SourceProductionContext context)
    {
        var processedTypes = new HashSet<string>();

        foreach (var typeInfo in typeInfos)
        {
            var typeNames = typeInfo.TypeArguments.Select(x => new string(x.HintName().Where(c => !InvalidPathChars.Contains(c)).ToArray()).Capitalize());
            var typeIdentifier = string.Join("_", typeNames);

            // Check if this combination of types has already been processed
            if (processedTypes.Contains(typeIdentifier))
            {
                continue; // Skip if already processed
            }

            var sourceCode = GenerateExtensionMethodsForOneOfType(typeInfo);
            var hintName = $"OneOfExtensions_{typeIdentifier}.g.cs";
            context.AddSource(hintName, SourceText.From(sourceCode, Encoding.UTF8));

            // Add this combination of types to the set of processed types
            processedTypes.Add(typeIdentifier);
        }
    }

    private static string GenerateExtensionMethodsForOneOfType(OneOfArgumentsInfo oneOfArgumentsInfo)
    {
        var sb = new StringBuilder();
        sb.AppendLine(AutoGeneratedHeader);
        sb.AppendLine();
        if (oneOfArgumentsInfo.TypeArguments.Any(x => x.IsNullableReferenceType()))
        {
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
        }
        foreach (var systemNamespace in oneOfArgumentsInfo.TypeArguments.SelectMany(x => x.SystemNamespaces()).Distinct())
        {
            sb.AppendLine($"using {systemNamespace};");
        }
        sb.AppendLine("using OneOf;");
        sb.AppendLine();
        sb.AppendLine("public static partial class OneOfTypeExtensions");
        sb.AppendLine("{");

        var fullyQualifiedNames = oneOfArgumentsInfo.TypeArguments.Select(x => x.FullyQualifiedName()).ToArray();

        for (var i = 0; i < oneOfArgumentsInfo.TypeArguments.Length; i++)
        {
            var fullyQualifiedName = oneOfArgumentsInfo.TypeArguments[i].FullyQualifiedName();
            var readableName = oneOfArgumentsInfo.TypeArguments[i].ReadableName;

            // Is<TypeName> method
            sb.AppendIndentedLine(1, $"public static bool Is{readableName}(this OneOf<{string.Join(", ", fullyQualifiedNames)}> oneOf)");
            sb.AppendIndentedLine(1, "{");
            sb.AppendIndentedLine(2, $"return oneOf.IsT{i};");
            sb.AppendIndentedLine(1, "}");

            // As<TypeName> method
            sb.AppendIndentedLine(1, $"public static {fullyQualifiedName} As{readableName}(this OneOf<{string.Join(", ", fullyQualifiedNames)}> oneOf)");
            sb.AppendIndentedLine(1, "{");
            sb.AppendIndentedLine(2, $"return oneOf.AsT{i};");
            sb.AppendIndentedLine(1, "}");

            // Map<TypeName> method
            var returnTypeArguments = new List<string>(fullyQualifiedNames) { [i] = "TResult" };
            sb.AppendIndentedLine(1, $"public static OneOf<{string.Join(", ", returnTypeArguments)}> Map{readableName}<TResult>(this OneOf<{string.Join(", ", fullyQualifiedNames)}> oneOf, Func<{fullyQualifiedName}, TResult> mapFunc)");
            sb.AppendIndentedLine(1, "{");
            sb.AppendIndentedLine(2, $"return oneOf.MapT{i}(mapFunc);");
            sb.AppendIndentedLine(1, "}");

            // TryPick<TypeName> method
            var remainderTypes = new List<string>(fullyQualifiedNames);
            remainderTypes.RemoveAt(i);
            if (remainderTypes.Count == 1)
            {
                // If only one type remains, output it directly
                sb.AppendIndentedLine(1, $"public static bool TryPick{readableName}(this OneOf<{string.Join(", ", fullyQualifiedNames)}> oneOf, out {fullyQualifiedName} value, out {remainderTypes.First()} remainder)");
            }
            else
            {
                // If more than one type remains, wrap it in OneOf
                sb.AppendIndentedLine(1, $"public static bool TryPick{readableName}(this OneOf<{string.Join(", ", fullyQualifiedNames)}> oneOf, out {fullyQualifiedName} value, out OneOf<{string.Join(", ", remainderTypes)}> remainder)");
            }
            sb.AppendIndentedLine(1, "{");
            sb.AppendIndentedLine(2, $"return oneOf.TryPickT{i}(out value, out remainder);");
            sb.AppendIndentedLine(1, "}");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}